// ==UserScript==
// @name         ç”Ÿå›¾åŠ©æ‰‹ (Fix v30 - Direct Call)
// @version      30
// @description  ç§»é™¤æ¨¡æ‹Ÿç‚¹å‡»ï¼Œæ”¹ä¸ºç›´æ¥è°ƒç”¨handleGeneration()å‡½æ•°ï¼Œæå‡ç¨³å®šæ€§
// @author       Walkeatround & Gemini & AI Assistant
// @match        */*
// @grant        none
// ==/UserScript==

(function () {
    'use strict';
    console.log('[SD Helper v30] Script loaded (Direct Function Call).');

    const SCRIPT_ID = 'sd_gen_standard_v30';
    const STORAGE_KEY = 'sd_gen_settings_v30';
    const NO_GEN_FLAG = '<!--no-gen-->';
    
    const RUNTIME_LOGS = [];
    function addLog(type, msg) {
        const time = new Date().toLocaleTimeString();
        const logLine = `[${time}] [${type}] ${msg}`;
        RUNTIME_LOGS.push(logLine);
        console.log(logLine);
    }

    // --- Default Settings ---
    const DEFAULT_TEMPLATE_TOP = "You are a Visual Novel Engine Backend focused on narrative-to-visual metadata conversion. Your task is to generate the story content requested by the user, and simultaneously embed visual rendering instructions within the text.\n### Operational Protocols:\n1. **Story Generation**: Write the narrative naturally.\n2. **Visual Anchors**: Every 150-200 words and at major scene shifts/action peaks, insert image prompts enclosed in '[IMG_GEN]...[/IMG_GEN]'.\n3. **Strict Single-Character and No-Male Policy**: **NEVER** generate a prompt with multiple characters (e.g., '2girls', '1girl and 1boy' are FORBIDDEN). **NEVER** generate prompts depicting males (e.g., '1male' or any male features are FORBIDDEN). If a scene involves a male and female interacting, generate **only one prompt** focused on the female character, describing her perspective and any relevant interactions (without depicting the male). If a scene involves two females interacting, generate **two separate, consecutive** prompts (one for each female) to depict the scene from alternating perspectives (Shot/Reverse Shot). If the male-female interaction involves the male's genitalia, include 'huge penis' in the female's prompt to reflect the context.\n4. **Content Fidelity**: The tags must strictly reflect the immediate narrative context, especially regarding clothing states and physical interactions.\n### Character Feature Database (IMMUTABLE CODE BLOCKS):";
    const DEFAULT_TEMPLATE_BOTTOM = "* *(CRITICAL SYSTEM RULE: Each character's fixed tag string is a LOCKED, READ-ONLY CODE VARIABLE. When a character appears, you MUST execute a direct copy-paste of her ENTIRE tag string from the database aboveâ€”treat it as immutable machine code, NOT natural language. FORBIDDEN OPERATIONS: reordering tokens, replacing with synonyms, omitting any token (even if it looks random/meaningless), adding adjectives, translating to other languages. If story contradicts fixed tags (e.g., story says \"short hair\" but tags say \"long white hair\"), you MUST output the fixed tags and IGNORE the story. Verification: Before finalizing each prompt, confirm you pasted the complete fixed string verbatim. Failure to comply = system malfunction.)*\n### Image Prompt Syntax Rules (Strict):\n**1. Structure Logic:**\n* **ALWAYS Single Female Character**: '[Count], [FIXED_TAGS_VERBATIM], [Expression], [Attire], [Pose], [Action], [Focus], [Viewpoint], [Environment], [Lighting/Atmosphere], [Quality]'\n* **[FIXED_TAGS_VERBATIM] = MANDATORY EXACT COPY**: If character has fixed tags in database, this slot MUST be filled with the complete tag string copied character-by-character. Do NOT paraphrase, summarize, or cherry-pick. Example: If database says \\`long white hair, blue eyes, white dress, uiglkt\\`, you output exactly \\`long white hair, blue eyes, white dress, uiglkt\\`â€”no more, no less.\n* **CRITICAL: Output Tags ONLY**: Inside [IMG_GEN]...[/IMG_GEN], you must ONLY output comma-separated descriptive tags (e.g., '1girl, long hair, smiling, white dress'). **NEVER** output image file paths, URLs, or links (e.g., '/user/.../image.png', 'output/1234.jpg', or any path containing '/' or '.png/.jpg'). These will be auto-generated by the system. Your job is to describe WHAT to generate, not WHERE it will be saved.\n**2. Component Definitions:**\n* **Count**: **STRICTLY** '1girl'.\n* **FIXED_TAGS_VERBATIM**: Entire fixed tag string from database, pasted without modification. If character has no fixed tags, skip this slot.\n* **Attire (Crucial)**: You must describe **Upper body + Lower body + Feet**.\n    * *Full*: e.g., 'white shirt, pleated skirt, thighhighs'.\n    * *Partial/Missing*: If a part is missing, use 'naked [part]' or 'bare [part]'. (e.g., 'topless', 'bare shoulders', 'bottomless', 'naked', 'barefoot', 'bare legs').\n* **Focus**: 'portrait', 'upper body', 'cowboy shot', or 'full body'.\n* **Viewpoint**: 'from below', 'from above', 'from side', 'from behind', 'from back', or 'straight-on'.\n* **Quality Suffix**: 'highly detailed, masterpiece, best quality, aesthetic, sensitive'\n### Execution Logic for Multi-Character Interactions:\n**Since simultaneous depiction is forbidden and males are prohibited, use the following techniques:**\n1. **Identify Interaction**: If Character A (male) and Character B (female) are interacting (e.g., talking, hugging, fighting, or involving genitalia).\n2. **Generate Only Female Prompt**: Focus solely on the female (Character B). Describe her action, reaction, or perspective towards the 'off-screen' male. If the interaction involves the male's genitalia, include 'huge penis' in the prompt.\n3. **For Two Females (e.g., Character B and Character C)**: Generate Prompt 1 for Character B (her action towards off-screen Character C), then immediately Prompt 2 for Character C (her reaction or reciprocal action).\n4. **Context Consistency**: Ensure the 'Environment', 'Lighting', and 'Quality' tags match exactly in paired prompts (for two-female interactions) to maintain scene continuity.\n### Example Output:\n(Narrative text...) WKR grabbed Hongryeon's hand tightly...\n[IMG_GEN]\n1girl, long white hair, blue eyes, white kimono, uiglkt, blushing, surprised, white kimono, sash, barefoot, looking up, hand being held, upper body, straight-on, warm light, highly detailed, masterpiece, best quality\n[/IMG_GEN]\n*(Note: The fixed tags 'long white hair, blue eyes, white kimono, uiglkt' were pasted verbatim from Hongryeon's database entry, regardless of story context.)*\n**Proceed with the story generation and prompt insertion now.**";

    const DEFAULT_SETTINGS = {
        enabled: true,
        startTag: '[IMG_GEN]',
        endTag: '[/IMG_GEN]',
        globalPrefix: 'best quality, masterpiece', 
        globalSuffix: '',
        globalNegative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
        injectEnabled: true,
        injectDepth: 0,
        injectRole: 'system',
        useRawMode: false, 
        injectPrompt: '',
        templateTop: DEFAULT_TEMPLATE_TOP,
        templateBottom: DEFAULT_TEMPLATE_BOTTOM,
        characters: [{ name: 'Character 1', tags: 'long white hair, blue eyes, white dress', enabled: true }],
        aiUpdateWithTemplate: false,
        llmConfig: { baseUrl: 'https://api.deepseek.com', apiKey: '', model: 'deepseek-chat', maxTokens: 4096, temperature: 0.7 }
    };

    let settings = DEFAULT_SETTINGS;
    let debounceTimer = null;
    let persistentListenCount = 0;

    // --- CSS ---
    const GLOBAL_CSS = `
    .sd-ui-container * { box-sizing: border-box; user-select: none; }
    .sd-ui-wrap {
        display: flex; flex-direction: column;
        background: transparent; border: none; margin: 5px 0;
        width: 100%; position: relative; transition: all 0.3s ease;
    }
    .sd-ui-toggle {
        text-align: center; cursor: pointer; font-size: 0.8em; opacity: 0.2;
        color: var(--SmartThemeBodyColor, #ccc); margin-bottom: 2px;
        transition: opacity 0.2s; line-height: 1;
    }
    .sd-ui-toggle:hover { opacity: 1; color: var(--SmartThemeQuoteColor, #00afff); }
    .sd-ui-viewport {
        position: relative; width: 100%; min-height: 50px;
        display: flex; align-items: center; justify-content: center;
        transition: all 0.3s ease; overflow: hidden;
    }
    .sd-ui-viewport.collapsed { display: none; }
    .sd-ui-image {
        max-width: 100%; max-height: 600px; width: auto; height: auto;
        border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        transition: opacity 0.2s;
        z-index: 1;
    }
    .sd-zone { position: absolute; background: transparent; }
    .sd-zone.delete { bottom: 0; left: 0; width: 40%; height: 5%; z-index: 100; cursor: no-drop; }
    .sd-zone.left { top: 0; left: 0; width: 20%; height: 90%; z-index: 90; cursor: w-resize; }
    .sd-zone.right { top: 0; right: 0; width: 20%; height: 90%; z-index: 90; cursor: e-resize; }
    .sd-zone.right.gen-mode { cursor: alias; }
    .sd-zone.top { top: 0; left: 0; width: 100%; height: 20%; z-index: 80; cursor: text; }
    .sd-ui-msg {
        position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.6); color: #fff; padding: 4px 8px;
        border-radius: 4px; font-size: 11px; pointer-events: none;
        opacity: 0; transition: opacity 0.3s; z-index: 15; white-space: nowrap;
    }
    .sd-ui-msg.show { opacity: 1; }
    .sd-placeholder {
        padding: 20px; border: 1px dashed rgba(255,255,255,0.1);
        border-radius: 6px; color: #aaa; font-size: 0.9em;
        text-align: center; width: 100%; opacity: 0.5;
    }
    /* Menu & Styles */
    .sd-tab-nav { display: flex; border-bottom: 1px solid var(--SmartThemeBorderColor, #555); margin-bottom: 15px; }
    .sd-tab-btn { padding: 8px 16px; cursor: pointer; opacity: 0.6; border-bottom: 2px solid transparent; font-weight: bold; }
    .sd-tab-btn:hover { opacity: 0.8; background: rgba(255,255,255,0.05); }
    .sd-tab-btn.active { opacity: 1; border-bottom-color: var(--SmartThemeQuoteColor, #00afff); color: var(--SmartThemeQuoteColor, #00afff); }
    .sd-tab-content { display: none; animation: sd-fade 0.2s; }
    .sd-tab-content.active { display: block; }
    @keyframes sd-fade { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    .sd-char-row { display: flex; gap: 5px; margin-bottom: 8px; align-items: flex-start; }
    .sd-char-name { flex: 0 0 25%; font-weight: bold; }
    .sd-char-tags { flex: 1; font-family: monospace; font-size: 0.9em; }
    .sd-char-del { flex: 0 0 30px; background: rgba(200,50,50,0.3); color: #fff; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; height: 38px; border-radius: 3px; }
    .sd-char-del:hover { background: rgba(200,50,50,0.6); }
    .sd-add-btn { width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px dashed #777; color: #ccc; cursor: pointer; margin-bottom: 15px; }
    .sd-add-btn:hover { background: rgba(255,255,255,0.15); color: #fff; border-color: #999; }
    .sd-accordion { cursor: pointer; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-top: 10px; display: flex; justify-content: space-between; align-items: center; }
    .sd-accordion:hover { background: rgba(0,0,0,0.3); }
    .sd-accordion-content { display: none; padding-top: 10px; }
    .sd-accordion-content.show { display: block; }
    .sd-ai-update-box { margin-bottom: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; display: none; border-left: 2px solid var(--SmartThemeQuoteColor); }
    .sd-ai-update-box.show { display: block; animation: sd-fade 0.2s; }
    `;

    // --- UTILITIES ---
    async function fetchModels(baseUrl, apiKey) {
        try {
            let url = baseUrl.replace(/\/$/, '');
            url += '/models';
            const headers = {};
            if (apiKey) headers['Authorization'] = `Bearer ${apiKey}`;

            const res = await fetch(url, { method: 'GET', headers: headers });
            if (!res.ok) {
                const errText = await res.text();
                throw new Error(`HTTP ${res.status}: ${errText.substring(0, 100)}`);
            }
            const data = await res.json();
            return data.data || data;
        } catch (e) {
            console.error(e);
            throw new Error(e.message || 'è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæˆ–API Key');
        }
    }

    async function callLLMForUpdate(prompt, instruction) {
        const config = settings.llmConfig;
        if (!config.baseUrl) throw new Error("API URL æœªé…ç½®");

        const url = config.baseUrl.replace(/\/$/, '') + '/chat/completions';
        const isDeepSeek = config.baseUrl.includes('deepseek');
        
        let safeMaxTokens = parseInt(config.maxTokens) || 500;
        if (isDeepSeek && safeMaxTokens > 8192) safeMaxTokens = 8192;

        let safeModel = config.model;
        if (!safeModel && isDeepSeek) safeModel = 'deepseek-chat';
        if (!safeModel) safeModel = 'gpt-3.5-turbo';

        let userContent = `Current Prompt: ${prompt}\n\nInstruction: ${instruction}\n\nModified Prompt:`;
        let systemContent = "You are a Stable Diffusion Prompt Assistant. Your goal is to modify the User's image prompt based on their specific instructions.\nRules:\n1. Output ONLY the modified comma-separated tags.\n2. Do NOT output markdown, prefixes, explanations, or chat.\n3. Keep existing tags unless the instruction specifically contradicts them.";

        if (settings.aiUpdateWithTemplate && settings.injectPrompt) {
            userContent = `### Full Context / Character Settings (Reference Only):\n${settings.injectPrompt}\n\n---\n\n### Task:\nCurrent Prompt: ${prompt}\n\nInstruction: ${instruction}\n\nModified Prompt:`;
            systemContent += "\n\nIMPORTANT: The user may provide a full 'Context/Template' containing instructions for writing stories. IGNORE all story-writing instructions. Your ONLY job is to modify the image tags based on the 'Instruction' and the character details found in the Context.";
        }

        const messages = [
            { role: "system", content: systemContent },
            { role: "user", content: userContent }
        ];

        const payload = {
            messages: messages,
            model: safeModel,
            temperature: parseFloat(config.temperature) || 0.7,
            max_tokens: safeMaxTokens,
            stream: false
        };
        
        const headers = { "Content-Type": "application/json" };
        if (config.apiKey) headers["Authorization"] = `Bearer ${config.apiKey}`;

        const res = await fetch(url, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(payload)
        });

        if (!res.ok) {
            const errText = await res.text();
            throw new Error(`API Error ${res.status}: ${errText.substring(0, 200)}`);
        }

        const data = await res.json();
        if (data.choices && data.choices.length > 0) {
            return data.choices[0].message.content.trim();
        }
        throw new Error("No response from AI");
    }

    // --- CORE API COMPATIBILITY FIX ---
    async function safeUpdateChat(messageIndex, newContent) {
        // Try modern API first
        if (typeof SillyTavern.setChatMessages === 'function') {
            try {
                await SillyTavern.setChatMessages([{
                    message_id: messageIndex,
                    message: newContent
                }], { refresh: 'affected' });
                return;
            } catch(e) {
                console.warn('[SD] setChatMessages failed, falling back to legacy method.', e);
            }
        }
        
        // Fallback for older ST or exceptions
        console.log('[SD] Using legacy chat update method.');
        if (SillyTavern.chat && SillyTavern.chat[messageIndex]) {
            SillyTavern.chat[messageIndex].mes = newContent;
            await SillyTavern.saveChat();
        }
    }

    // --- Initialization ---
    const waitForCore = setInterval(() => {
        if (typeof SillyTavern !== 'undefined' && typeof $ !== 'undefined' && SillyTavern.chat) {
            clearInterval(waitForCore);
            injectGlobalStyles(); 
            loadSettings();
            initScript();
        }
    }, 500);

    function injectGlobalStyles() {
        if ($('#sd-global-css-v30').length) return;
        $('<style id="sd-global-css-v30">').text(GLOBAL_CSS).appendTo('head');
        console.log('[SD] Global CSS injected.');
    }

    function loadSettings() {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
            try { 
                const parsed = JSON.parse(stored);
                settings = { ...DEFAULT_SETTINGS, ...parsed };
                if (!parsed.llmConfig) settings.llmConfig = DEFAULT_SETTINGS.llmConfig;
                else settings.llmConfig = { ...DEFAULT_SETTINGS.llmConfig, ...parsed.llmConfig };
            } 
            catch (e) { console.error(e); }
        }
    }

    function saveSettings() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    }

    function initScript() {
        addMenuItem();
        initGlobalListeners();
        registerSTEvents();
        setTimeout(processChatDOM, 1000);
    }

    // --- Global Event Delegation ---
    function initGlobalListeners() {
        const $chat = $('#chat');
        
        const getState = ($target) => {
            const $wrap = $target.closest('.sd-ui-wrap');
            const $mes = $wrap.closest('.mes');
            const mesId = $mes.attr('mesid');
            if (!$wrap.length || !mesId) return null;

            return {
                $wrap,
                mesId,
                prompt: decodeURIComponent($wrap.attr('data-prompt')),
                images: JSON.parse(decodeURIComponent($wrap.attr('data-images'))),
                preventAuto: $wrap.attr('data-prevent-auto') === 'true',
                blockIdx: parseInt($wrap.attr('data-block-idx')),
                el: {
                    img: $wrap.find('.sd-ui-image'),
                    msg: $wrap.find('.sd-ui-msg'),
                    viewport: $wrap.find('.sd-ui-viewport'),
                    toggle: $wrap.find('.sd-ui-toggle'),
                }
            };
        };

        $chat.on('click', '.sd-ui-toggle', function(e) {
            e.stopPropagation();
            const s = getState($(this));
            if(!s) return;
            s.el.viewport.toggleClass('collapsed');
            s.el.toggle.text(s.el.viewport.hasClass('collapsed') ? 'â–¿' : 'â–µ');
        });

        // LEFT NAV
        $chat.on('click', '.sd-zone.left', function(e) {
            e.stopPropagation();
            const s = getState($(this));
            if(!s) return;
            
            const rawIdx = s.$wrap.attr('data-cur-idx');
            let curIdx = (rawIdx !== undefined && rawIdx !== '') ? parseInt(rawIdx) : (s.images.length - 1);
            
            if (curIdx > 0) {
                curIdx--;
                updateWrapperView(s.$wrap, s.images, curIdx);
            }
        });

        // RIGHT NAV & GEN
        $chat.on('click', '.sd-zone.right', function(e) {
            e.stopPropagation();
            const s = getState($(this));
            if(!s) return;
            
            const rawIdx = s.$wrap.attr('data-cur-idx');
            let curIdx = (rawIdx !== undefined && rawIdx !== '') ? parseInt(rawIdx) : (s.images.length - 1);
            const count = s.images.length;

            if (curIdx < count - 1) {
                curIdx++;
                updateWrapperView(s.$wrap, s.images, curIdx);
            } else {
                addLog('CLICK_GEN', `Block ${s.blockIdx}: ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»å³ä¾§åŒºåŸŸè§¦å‘ç”Ÿå›¾`);
                handleGeneration(s);
            }
        });
        
        $chat.on('click', '.sd-ui-image', function() {
            const src = $(this).attr('src');
            if(src) window.open(src, '_blank');
        });

        $chat.on('click', '.sd-zone.delete', async function(e) {
            e.stopPropagation();
            if (!confirm('ç¡®å®šåˆ é™¤è¿™å¼ å›¾ç‰‡å—ï¼Ÿ')) return;
            const s = getState($(this));
            if(!s) return;
            
            const rawIdx = s.$wrap.attr('data-cur-idx');
            let curIdx = (rawIdx !== undefined && rawIdx !== '') ? parseInt(rawIdx) : (s.images.length - 1);
            
            s.images.splice(curIdx, 1);
            if (s.images.length === 0) s.preventAuto = true;
            
            await updateChatData(s.mesId, s.blockIdx, s.prompt, s.images, s.preventAuto);
            updateWrapperView(s.$wrap, s.images, Math.max(0, s.images.length - 1));
        });

        $chat.on('click', '.sd-zone.top', function(e) {
            e.stopPropagation();
            const s = getState($(this));
            if(!s) return;
            openEditPopup(s);
        });
    }

    // --- Action Logic ---
    async function handleGeneration(state) {
        addLog('GEN_START', `Block ${state.blockIdx}: å¼€å§‹ç”Ÿå›¾æµç¨‹ - Promptå‰ç¼€: "${state.prompt.substring(0, 50)}..."`);
        
        if (state.$wrap.data('generating')) {
            addLog('GEN_SKIP', `Block ${state.blockIdx}: å·²æœ‰ç”Ÿå›¾ä»»åŠ¡è¿›è¡Œä¸­ï¼Œè·³è¿‡`);
            return;
        }
        state.$wrap.data('generating', true);
        addLog('GEN_LOCK', `Block ${state.blockIdx}: å·²è®¾ç½®ç”Ÿæˆé”ï¼Œé˜²æ­¢é‡å¤è§¦å‘`);
        
        const p = state.prompt;
        const prefix = settings.globalPrefix ? settings.globalPrefix + ', ' : '';
        const suffix = settings.globalSuffix ? ', ' + settings.globalSuffix : '';
        let finalPrompt = (prefix + p + suffix).replace(/,\s*,/g, ',').trim();
        addLog('GEN_PROMPT', `Block ${state.blockIdx}: æœ€ç»ˆPrompté•¿åº¦=${finalPrompt.length}, è´Ÿé¢è¯=${settings.globalNegative ? 'å·²è®¾ç½®' : 'æœªè®¾ç½®'}`);
        
        let cmd = `/sd quiet=true ${settings.globalNegative ? `negative="${escapeArg(settings.globalNegative)}"` : ''} ${finalPrompt}`;
        addLog('GEN_CMD', `Block ${state.blockIdx}: å‘½ä»¤å·²æ„é€  - é•¿åº¦=${cmd.length}`);
        
        const showMsg = (txt) => {
            state.el.msg.text(txt).addClass('show');
            setTimeout(() => state.el.msg.removeClass('show'), 2000);
        };

        showMsg('â³ è¯·æ±‚ä¸­...');
        addLog('GEN_UI', `Block ${state.blockIdx}: UIçŠ¶æ€æ›´æ–° - æ˜¾ç¤º"è¯·æ±‚ä¸­"`);
        state.el.img.css('opacity', '0.5');

        try {
            addLog('GEN_API', `Block ${state.blockIdx}: æ­£åœ¨è°ƒç”¨ triggerSlash API...`);
            const result = await triggerSlash(cmd);
            addLog('GEN_RESULT', `Block ${state.blockIdx}: APIè¿”å›ç»“æœé•¿åº¦=${result ? result.length : 0}`);
            
            const newUrls = (result || '').match(/(https?:\/\/|\/|output\/)[^\s"']+\.(png|jpg|jpeg|webp|gif)/gi) || [];
            addLog('GEN_PARSE', `Block ${state.blockIdx}: è§£æåˆ° ${newUrls.length} ä¸ªå›¾ç‰‡URL`);
            
            if (newUrls.length > 0) {
                addLog('SUCCESS', `Block ${state.blockIdx}: æˆåŠŸç”Ÿæˆå›¾ç‰‡ - URLs: ${newUrls.join(', ')}`);
                showMsg('âœ… æˆåŠŸ');
                newUrls.forEach(u => state.images.push(u));
                const uniqueImages = [...new Set(state.images)];
                addLog('GEN_SAVE', `Block ${state.blockIdx}: å›¾ç‰‡æ•°ç»„æ›´æ–° - å»é‡åå…± ${uniqueImages.length} å¼ `);
                
                await updateChatData(state.mesId, state.blockIdx, state.prompt, uniqueImages, false);
                updateWrapperView(state.$wrap, uniqueImages, uniqueImages.length - 1);
                addLog('GEN_COMPLETE', `Block ${state.blockIdx}: ç”Ÿå›¾æµç¨‹å®Œæˆï¼ŒUIå·²æ›´æ–°`);
            } else {
                addLog('WARN', `Block ${state.blockIdx}: APIå“åº”ä¸­æœªæ‰¾åˆ°å›¾ç‰‡URL`);
                showMsg('âš ï¸ æ— ç»“æœ');
            }
        } catch (err) {
            addLog('ERROR', `Block ${state.blockIdx}: ç”Ÿå›¾å¤±è´¥ - ${err.message}`);
            showMsg('âŒ é”™è¯¯');
        } finally {
            state.$wrap.data('generating', false);
            state.el.img.css('opacity', '1');
            addLog('GEN_UNLOCK', `Block ${state.blockIdx}: å·²è§£é™¤ç”Ÿæˆé”`);
        }
    }

    function updateWrapperView($wrap, images, idx) {
        const count = images.length;
        if (idx >= count) idx = count - 1;
        if (idx < 0) idx = 0;

        $wrap.attr('data-cur-idx', idx);
        $wrap.attr('data-images', encodeURIComponent(JSON.stringify(images)));

        const $img = $wrap.find('.sd-ui-image');
        const $ph = $wrap.find('.sd-placeholder');
        const $right = $wrap.find('.sd-zone.right');
        const $left = $wrap.find('.sd-zone.left');
        const $del = $wrap.find('.sd-zone.delete');
        const $msg = $wrap.find('.sd-ui-msg');

        if (count === 0) {
            $img.hide(); 
            $ph.show();
            $right.addClass('gen-mode').attr('title', 'ç‚¹å‡»ç”Ÿæˆå›¾ç‰‡');
            $left.hide(); 
            $del.hide();
        } else {
            $ph.hide();
            $img.attr('src', images[idx]).show();
            $left.toggle(idx > 0);
            $del.show();
            if (idx === count - 1) $right.addClass('gen-mode').attr('title', 'ç”Ÿæˆæ–°å›¾');
            else $right.removeClass('gen-mode').attr('title', 'ä¸‹ä¸€å¼ ');
            
            $msg.text(`${idx + 1} / ${count}`).addClass('show');
            setTimeout(() => $msg.removeClass('show'), 2000);
        }
    }

    async function updateChatData(mesId, blockIndex, prompt, images, preventAuto) {
        const index = parseInt(mesId);
        const chat = SillyTavern.chat;
        if (!chat || !chat[index]) return;

        const innerContent = rebuildBlockString(prompt, images, preventAuto);
        const newBlock = settings.startTag + '\n' + innerContent + '\n' + settings.endTag;

        const sTag = escapeRegExp(settings.startTag);
        const eTag = escapeRegExp(settings.endTag);
        const regex = new RegExp(`${sTag}([\\s\\S]*?)${eTag}`, 'g');
        
        let content = chat[index].mes;
        const matches = [...content.matchAll(regex)];
        
        if (matches.length > blockIndex) {
            const targetMatch = matches[blockIndex];
            const startIndex = targetMatch.index;
            const endIndex = startIndex + targetMatch[0].length;
            const newContent = content.substring(0, startIndex) + newBlock + content.substring(endIndex);
            
            await safeUpdateChat(index, newContent);
            addLog('SAVE', `Saved block index ${blockIndex} to message ${index}`);
        }
    }

    // âœ… æ–°å¢ï¼šå¸¦æŒç»­ç›‘å¬çš„å¤„ç†å‡½æ•°ï¼ˆ5æ¬¡é—´éš”2sï¼‰
    function processChatDOMWithPersistentListening() {
        addLog('EVENT', `[ç›‘å¬è§¦å‘] å¼€å§‹å¤„ç†èŠå¤©DOM (ç¬¬ ${persistentListenCount + 1} æ¬¡)`);
        processChatDOM();
        
        // æŒç»­ç›‘å¬5æ¬¡ï¼Œæ¯æ¬¡é—´éš”2ç§’
        if (persistentListenCount < 4) {
            persistentListenCount++;
            setTimeout(() => {
                addLog('EVENT', `[æŒç»­ç›‘å¬] ç¬¬ ${persistentListenCount + 1} æ¬¡å»¶è¿Ÿå¤„ç†`);
                processChatDOM();
                processChatDOMWithPersistentListening();
            }, 2000);
        } else {
            persistentListenCount = 0;
            addLog('EVENT', '[ç›‘å¬ç»“æŸ] å®Œæˆ5æ¬¡æŒç»­ç›‘å¬');
        }
    }

    // âœ… è¾…åŠ©å‡½æ•°ï¼šä» $wrap æ„é€  state å¯¹è±¡
    function buildStateFromWrap($wrap) {
        const $mes = $wrap.closest('.mes');
        const mesId = $mes.attr('mesid');
        if (!mesId) {
            addLog('ERROR', 'buildStateFromWrap: æ— æ³•è·å– mesIdï¼Œè·³è¿‡');
            return null;
        }

        const blockIdx = parseInt($wrap.attr('data-block-idx'));
        const imgCount = JSON.parse(decodeURIComponent($wrap.attr('data-images'))).length;
        const prevent = $wrap.attr('data-prevent-auto') === 'true';
        
        addLog('STATE_BUILD', `Block ${blockIdx}: æ„é€  state å¯¹è±¡ - mesId=${mesId}, å›¾ç‰‡æ•°=${imgCount}, preventAuto=${prevent}`);

        return {
            $wrap,
            mesId,
            prompt: decodeURIComponent($wrap.attr('data-prompt')),
            images: JSON.parse(decodeURIComponent($wrap.attr('data-images'))),
            preventAuto: prevent,
            blockIdx: blockIdx,
            el: {
                img: $wrap.find('.sd-ui-image'),
                msg: $wrap.find('.sd-ui-msg'),
                viewport: $wrap.find('.sd-ui-viewport'),
                toggle: $wrap.find('.sd-ui-toggle')
            }
        };
    }

    function processChatDOM() {
        if (!settings.enabled) return;

        const sTag = settings.startTag;
        const eTag = settings.endTag;
        const pattern = `${escapeRegExp(sTag)}([\\s\\S]*?)${escapeRegExp(eTag)}`;
        const regex = new RegExp(pattern, 'g');

        $('.mes_text').each(function() {
            const $el = $(this);
            
            let blockIdx = 0;
            
            const hasTHRender = $el.find('.TH-render').length > 0;
            
            if (hasTHRender) {
                console.log('[SD] æ£€æµ‹åˆ°TH-renderï¼Œä½¿ç”¨ç²¾å‡†æ›¿æ¢æ¨¡å¼');
                
                let processedCount = 0;
                
                $el.children().each(function() {
                    const $child = $(this);
                    
                    if ($child.hasClass('TH-render') || $child.find('.TH-render').length > 0) {
                        console.log('[SD] è·³è¿‡TH-renderå…ƒç´ ');
                        return;
                    }
                    
                    if ($child.find('.sd-ui-wrap').length > 0) {
                        return;
                    }
                    
                    const childHtml = $child.html();
                    
                    if (childHtml && childHtml.indexOf(sTag) !== -1) {
                        let hasChange = false;
                        
                        const newHtml = childHtml.replace(regex, (match, content) => {
                            hasChange = true;
                            const currentIdx = blockIdx++;
                            const parsed = parseBlockContent(content);
                            const initIdx = Math.max(0, parsed.images.length - 1);
                            return createUIHtml(parsed.prompt, parsed.images, parsed.preventAuto, currentIdx, initIdx);
                        });
                        
                        if (hasChange) {
                            $child.html(newHtml);
                            processedCount++;
                            console.log('[SD] å·²å¤„ç†å­å…ƒç´ :', $child[0].tagName, 'å—ç´¢å¼•:', blockIdx - 1);
                            
                            setTimeout(() => {
                                $child.find('.sd-ui-msg.show').removeClass('show');
                                
                                // âœ… æ”¹ä¸ºç›´æ¥è°ƒç”¨ handleGenerationï¼Œä¸å†æ¨¡æ‹Ÿç‚¹å‡»
                                $child.find('.sd-ui-wrap').each(function() {
                                    const $w = $(this);
                                    const prevent = $w.attr('data-prevent-auto') === 'true';
                                    const imgs = JSON.parse(decodeURIComponent($w.attr('data-images')));
                                    const currentBlockIdx = parseInt($w.attr('data-block-idx'));
                                    
                                    addLog('AUTO_CHECK', `Block ${currentBlockIdx}: æ£€æŸ¥è‡ªåŠ¨ç”Ÿå›¾æ¡ä»¶ - å›¾ç‰‡æ•°=${imgs.length}, preventAuto=${prevent}`);
                                    
                                    if (imgs.length === 0 && !prevent) {
                                        const delay = 500 + (currentBlockIdx * 1000);
                                        addLog('AUTO_SCHEDULE', `Block ${currentBlockIdx}: æ»¡è¶³è‡ªåŠ¨ç”Ÿå›¾æ¡ä»¶ï¼Œå°†åœ¨ ${delay}ms åè§¦å‘`);
                                        
                                        setTimeout(() => {
                                            addLog('AUTO_TRIGGER', `Block ${currentBlockIdx}: å»¶è¿Ÿæ—¶é—´åˆ°ï¼Œå¼€å§‹æ„é€  state å¹¶è°ƒç”¨ç”Ÿå›¾å‡½æ•°`);
                                            const state = buildStateFromWrap($w);
                                            if (state) {
                                                addLog('AUTO_GEN', `Block ${state.blockIdx}: ç›´æ¥è°ƒç”¨ handleGeneration()`);
                                                handleGeneration(state);
                                            } else {
                                                addLog('AUTO_FAIL', `Block ${currentBlockIdx}: state æ„é€ å¤±è´¥ï¼Œæ— æ³•è§¦å‘è‡ªåŠ¨ç”Ÿå›¾`);
                                            }
                                        }, delay);
                                    } else {
                                        if (imgs.length > 0) {
                                            addLog('AUTO_SKIP', `Block ${currentBlockIdx}: å·²æœ‰ ${imgs.length} å¼ å›¾ç‰‡ï¼Œè·³è¿‡è‡ªåŠ¨ç”Ÿå›¾`);
                                        }
                                        if (prevent) {
                                            addLog('AUTO_SKIP', `Block ${currentBlockIdx}: preventAuto=trueï¼Œè·³è¿‡è‡ªåŠ¨ç”Ÿå›¾`);
                                        }
                                    }
                                });
                            }, 100);
                        }
                    }
                });
                
                if (processedCount > 0) {
                    console.log(`[SD] ç²¾å‡†æ›¿æ¢å®Œæˆï¼Œå¤„ç†äº† ${processedCount} ä¸ªå…ƒç´ ï¼Œå…± ${blockIdx} ä¸ªå—`);
                }
                
                return;
            }
            
            const html = $el.html();
            if (html.indexOf(sTag) === -1) return;
            if ($el.find('.sd-ui-wrap').length > 0 && !$el.attr('data-dirty')) return;

            let hasChange = false;
            
            const newHtml = html.replace(regex, (match, content) => {
                hasChange = true;
                const currentIdx = blockIdx++;
                const parsed = parseBlockContent(content);
                const initIdx = Math.max(0, parsed.images.length - 1);
                return createUIHtml(parsed.prompt, parsed.images, parsed.preventAuto, currentIdx, initIdx);
            });

            if (hasChange) {
                $el.html(newHtml);
                
                setTimeout(() => $el.find('.sd-ui-msg.show').removeClass('show'), 2000);
                
                // âœ… æ”¹ä¸ºç›´æ¥è°ƒç”¨ handleGenerationï¼Œä¸å†æ¨¡æ‹Ÿç‚¹å‡»
                $el.find('.sd-ui-wrap').each(function() {
                    const $w = $(this);
                    const prevent = $w.attr('data-prevent-auto') === 'true';
                    const imgs = JSON.parse(decodeURIComponent($w.attr('data-images')));
                    const currentBlockIdx = parseInt($w.attr('data-block-idx'));
                    
                    addLog('AUTO_CHECK', `Block ${currentBlockIdx}: æ£€æŸ¥è‡ªåŠ¨ç”Ÿå›¾æ¡ä»¶ - å›¾ç‰‡æ•°=${imgs.length}, preventAuto=${prevent}`);
                    
                    if (imgs.length === 0 && !prevent) {
                        const delay = 500 + (blockIdx * 1000);
                        addLog('AUTO_SCHEDULE', `Block ${currentBlockIdx}: æ»¡è¶³è‡ªåŠ¨ç”Ÿå›¾æ¡ä»¶ï¼Œå°†åœ¨ ${delay}ms åè§¦å‘`);
                        
                        setTimeout(() => {
                            addLog('AUTO_TRIGGER', `Block ${currentBlockIdx}: å»¶è¿Ÿæ—¶é—´åˆ°ï¼Œå¼€å§‹æ„é€  state å¹¶è°ƒç”¨ç”Ÿå›¾å‡½æ•°`);
                            const state = buildStateFromWrap($w);
                            if (state) {
                                addLog('AUTO_GEN', `Block ${state.blockIdx}: ç›´æ¥è°ƒç”¨ handleGeneration()`);
                                handleGeneration(state);
                            } else {
                                addLog('AUTO_FAIL', `Block ${currentBlockIdx}: state æ„é€ å¤±è´¥ï¼Œæ— æ³•è§¦å‘è‡ªåŠ¨ç”Ÿå›¾`);
                            }
                        }, delay);
                    } else {
                        if (imgs.length > 0) {
                            addLog('AUTO_SKIP', `Block ${currentBlockIdx}: å·²æœ‰ ${imgs.length} å¼ å›¾ç‰‡ï¼Œè·³è¿‡è‡ªåŠ¨ç”Ÿå›¾`);
                        }
                        if (prevent) {
                            addLog('AUTO_SKIP', `Block ${currentBlockIdx}: preventAuto=trueï¼Œè·³è¿‡è‡ªåŠ¨ç”Ÿå›¾`);
                        }
                    }
                });
            }
        });
    }

    function parseBlockContent(rawContent) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawContent;
        let text = tempDiv.innerText || tempDiv.textContent || '';
        const preventAuto = rawContent.includes(NO_GEN_FLAG);
        const urlRegex = /(https?:\/\/|\/|output\/)[^\s"']+\.(png|jpg|jpeg|webp|gif)/gi;
        const images = text.match(urlRegex) || [];
        let prompt = text.replace(urlRegex, '').trim();
        prompt = prompt.replace(NO_GEN_FLAG, '').trim();
        prompt = prompt.replace(/^\s*[\r\n]/gm, '').trim();
        return { prompt, images, preventAuto };
    }

    function rebuildBlockString(prompt, images, preventAuto) {
        let content = prompt;
        if (images.length > 0) content += '\n' + images.join('\n');
        else if (preventAuto) content += '\n' + NO_GEN_FLAG;
        return content;
    }

    function createUIHtml(prompt, images, preventAuto, blockIdx, initIdx) {
        const safePrompt = encodeURIComponent(prompt);
        const safeImages = encodeURIComponent(JSON.stringify(images));
        const hasImages = images.length > 0;
        const currentImg = hasImages ? images[initIdx] : '';
        const currentCountText = hasImages ? `${initIdx + 1} / ${images.length}` : '';

        return `
        <div class="sd-ui-container">
            <div class="sd-ui-wrap" 
                 data-prompt="${safePrompt}" 
                 data-images="${safeImages}" 
                 data-prevent-auto="${preventAuto}"
                 data-block-idx="${blockIdx}"
                 data-cur-idx="${initIdx}">
                <div class="sd-ui-toggle" title="æŠ˜å /å±•å¼€">â–µ</div>
                <div class="sd-ui-viewport">
                    <div class="sd-zone top" title="ç¼–è¾‘æç¤ºè¯"></div>
                    <div class="sd-zone left" title="ä¸Šä¸€å¼ " style="display:${initIdx > 0 ? 'block' : 'none'}"></div>
                    <div class="sd-zone right ${hasImages && initIdx === images.length-1 ? 'gen-mode' : ''} ${!hasImages ? 'gen-mode' : ''}" 
                         title="${hasImages && initIdx < images.length-1 ? 'ä¸‹ä¸€å¼ ' : 'ç”Ÿæˆæ–°å›¾'}"></div>
                    <div class="sd-zone delete" title="åˆ é™¤å½“å‰å›¾" style="display:${hasImages ? 'block' : 'none'}"></div>
                    <div class="sd-ui-msg ${hasImages ? 'show' : ''}">${currentCountText}</div>
                    <img class="sd-ui-image" src="${currentImg}" style="display:${hasImages ? 'block' : 'none'}" />
                    <div class="sd-placeholder" style="display:${hasImages ? 'none' : 'block'}">
                        <i class="fa-solid fa-image"></i> ç­‰å¾…ç”Ÿæˆ...<br>
                        <small>ï¼ˆç´¢å¼•: ${blockIdx}ï¼‰</small>
                    </div>
                </div>
            </div>
        </div>`;
    }

    function escapeArg(s) { return String(s || '').replace(/["\\]/g, '\\$&'); }
    function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

    // --- Menus & Popups ---
    function addMenuItem() {
        const extensionsMenu = $('#extensionsMenu');
        const menuItemId = `${SCRIPT_ID}-menu`;
        if (extensionsMenu.length === 0) { setTimeout(addMenuItem, 1000); return; }
        if ($(`#${menuItemId}`).length > 0) return;
        const menuItemHTML = `
            <div class="list-group-item flex-container flexGap5 interactable" id="${menuItemId}" title="è®¾ç½®SDç”Ÿå›¾åŠ©æ‰‹">
                <div class="fa-fw fa-solid fa-paintbrush extensionsMenuExtensionButton"></div>
                <span>ç”Ÿå›¾åŠ©æ‰‹</span>
            </div>`;
        const $menuItem = $(menuItemHTML);
        $menuItem.on('click', (e) => { e.stopPropagation(); openSettingsPopup(); });
        extensionsMenu.append($menuItem);
    }

    function openEditPopup(state) {
        const timestamp = Date.now();
        const taId = `sd-edit-${timestamp}`; 
        const btnModId = `sd-mod-${timestamp}`; 
        const btnGenId = `sd-gen-${timestamp}`;
        const btnAiToggleId = `sd-ai-toggle-${timestamp}`;
        const aiBoxId = `sd-ai-box-${timestamp}`;
        const aiInputId = `sd-ai-input-${timestamp}`;
        const btnAiRunId = `sd-ai-run-${timestamp}`;

        const html = `
            <div style="padding:10px;">
                <h3>ç¼–è¾‘æç¤ºè¯ (Block ${state.blockIdx})</h3>
                <textarea id="${taId}" class="text_pole" rows="5" style="width:100%; font-family:monospace; margin-bottom:10px;">${state.prompt}</textarea>
                
                <div id="${aiBoxId}" class="sd-ai-update-box">
                    <label style="font-size:0.9em; font-weight:bold;">AIä¿®æ”¹æŒ‡ä»¤ (Instruction):</label>
                    <textarea id="${aiInputId}" class="text_pole" rows="2" placeholder="ä¾‹å¦‚ï¼šæŠŠè¡£æœæ”¹æˆçº¢è‰²ï¼Œå¢åŠ ä¸‹é›¨èƒŒæ™¯..." style="width:100%; margin:5px 0;"></textarea>
                    <div style="text-align:center; margin-top:5px;">
                        <button id="${btnAiRunId}" class="menu_button" style="font-size:0.9em; width:100%;">ğŸš€ æ‰§è¡Œæ›´æ–°</button>
                    </div>
                </div>

                <div style="display:flex; gap:10px; margin-top:10px;">
                    <button id="${btnAiToggleId}" class="menu_button" style="flex:1;" title="AI è¾…åŠ©ä¿®æ”¹">ğŸª„ AIä¼˜åŒ–</button>
                    <button id="${btnModId}" class="menu_button" style="flex:1;">ä»…ä¿®æ”¹</button>
                    <button id="${btnGenId}" class="menu_button" style="flex:1; background:var(--SmartThemeQuoteColor); color:#fff;">ç”Ÿæˆ</button>
                </div>
            </div>`;
            
        SillyTavern.callGenericPopup(html, 1, '', { wide: false });
        
        setTimeout(() => {
            const $promptArea = $(`#${taId}`);
            const $aiBox = $(`#${aiBoxId}`);
            
            $(`#${btnAiToggleId}`).on('click', () => $aiBox.toggleClass('show'));

            $(`#${btnAiRunId}`).on('click', async function() {
                const instruction = $(`#${aiInputId}`).val().trim();
                if(!instruction) { toastr.warning('è¯·è¾“å…¥æŒ‡ä»¤'); return; }
                const btn = $(this);
                const originalText = btn.text();
                btn.prop('disabled', true).text('ğŸ¤– å¤„ç†ä¸­...');
                try {
                    const currentPrompt = $promptArea.val();
                    const newPrompt = await callLLMForUpdate(currentPrompt, instruction);
                    $promptArea.val(newPrompt);
                    toastr.success('AIæ›´æ–°æˆåŠŸ');
                    $aiBox.removeClass('show');
                } catch(e) { toastr.error(e.message); }
                finally { btn.prop('disabled', false).text(originalText); }
            });

            $(`#${btnModId}`).on('click', async function() {
                state.prompt = $promptArea.val().trim();
                state.$wrap.attr('data-prompt', encodeURIComponent(state.prompt));
                closeCurrentPopup(this);
                await updateChatData(state.mesId, state.blockIdx, state.prompt, state.images, state.preventAuto);
            });
            
            $(`#${btnGenId}`).on('click', async function() {
                state.prompt = $promptArea.val().trim();
                state.$wrap.attr('data-prompt', encodeURIComponent(state.prompt));
                closeCurrentPopup(this);
                await updateChatData(state.mesId, state.blockIdx, state.prompt, state.images, state.preventAuto);
                state.prompt = $promptArea.val().trim();
                addLog('POPUP_GEN', `Block ${state.blockIdx}: ç”¨æˆ·é€šè¿‡ç¼–è¾‘å¼¹çª—è§¦å‘ç”Ÿå›¾`);
                handleGeneration(state);
            });
        }, 100);
    }

    function closeCurrentPopup(triggerBtn) {
        try {
            const $btn = $(triggerBtn);
            const $popup = $btn.closest('.popup, .popup-body, dialog');
            if ($popup.length) {
                const $okBtn = $popup.find('.popup-button-ok');
                if ($okBtn.length && $okBtn.is(':visible')) { $okBtn.trigger('click'); return; }
            }
            const $lastOk = $('.popup-button-ok:visible').last();
            if ($lastOk.length) $lastOk.trigger('click');
            else if (typeof SillyTavern !== 'undefined' && SillyTavern.closePopup) SillyTavern.closePopup();
            else $('#genericPopupClose').click();
        } catch (e) { console.error('[SD] Close popup failed', e); }
    }

    function openSettingsPopup() {
        const timestamp = Date.now();
        const btnSaveId = `sd-save-${timestamp}`; const tabInjId = `sd-tab-inj-${timestamp}`; const tabCfgId = `sd-tab-cfg-${timestamp}`; const tabApiId = `sd-tab-api-${timestamp}`; const tabLogId = `sd-tab-log-${timestamp}`;
        const btnResetId = `sd-reset-${timestamp}`;
        const contentInjId = `sd-content-inj-${timestamp}`; const contentCfgId = `sd-content-cfg-${timestamp}`; const contentApiId = `sd-content-api-${timestamp}`; const contentLogId = `sd-content-log-${timestamp}`;
        const btnExpId = `sd-export-${timestamp}`; const btnImpId = `sd-import-${timestamp}`;
        const logText = RUNTIME_LOGS.join('\n');

        const popupHtml = `
            <div style="padding: 10px; max-height: 70vh; overflow-y: auto; overflow-x: hidden; scrollbar-width: thin;">
                <h3 style="margin-bottom: 15px;">ğŸ¨ SDç”Ÿå›¾åŠ©æ‰‹ v30</h3>
                <div class="sd-tab-nav">
                    <div id="${tabInjId}" class="sd-tab-btn active">æ³¨å…¥(Prompt)</div>
                    <div id="${tabCfgId}" class="sd-tab-btn">åŸºç¡€è®¾ç½®</div>
                    <div id="${tabApiId}" class="sd-tab-btn">APIè®¾ç½®</div>
                    <div id="${tabLogId}" class="sd-tab-btn">æ—¥å¿—</div>
                </div>
                <div id="${contentInjId}" class="sd-tab-content active">
                    <div style="margin-bottom:15px; padding:10px; background:rgba(0,0,0,0.1); border-radius:5px;">
                        <label class="checkbox_label" style="display: flex; align-items: center; margin-bottom:10px;">
                            <input type="checkbox" id="sd-inject-enable" ${settings.injectEnabled ? 'checked' : ''} /> 
                            <span style="margin-left: 8px; font-weight:bold;">å¯ç”¨æç¤ºè¯æ³¨å…¥ (Context Injection)</span>
                        </label>
                        <label class="checkbox_label" style="display: flex; align-items: center; margin-bottom:10px;">
                            <input type="checkbox" id="sd-ai-tmpl-enable" ${settings.aiUpdateWithTemplate ? 'checked' : ''} /> 
                            <span style="margin-left: 8px;">AIä¿®å›¾æ—¶æºå¸¦å®Œæ•´æ¨¡ç‰ˆ (Include Template in AI Update)</span>
                        </label>
                        <div style="display:flex; gap:15px; margin-top:10px;">
                            <div style="flex:1"><label>æ’å…¥æ·±åº¦ (0=æœ€å):</label><input type="number" id="sd-inject-depth" class="text_pole" value="${settings.injectDepth}" min="0" max="50" style="width:100%" /></div>
                            <div style="flex:1">
                                <label>å‘é€èº«ä»½ (Role):</label>
                                <select id="sd-inject-role" class="text_pole" style="width:100%">
                                    <option value="system" ${settings.injectRole === 'system' ? 'selected' : ''}>System (ç³»ç»Ÿ)</option>
                                    <option value="user" ${settings.injectRole === 'user' ? 'selected' : ''}>User (ç”¨æˆ·)</option>
                                    <option value="assistant" ${settings.injectRole === 'assistant' ? 'selected' : ''}>Assistant (AI)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div style="margin-bottom:15px; text-align:right;"><small style="color:#aaa; cursor:pointer;" id="sd-mode-toggle">[åˆ‡æ¢æ¨¡å¼: ${settings.useRawMode ? 'åŸå§‹æ–‡æœ¬' : 'è§’è‰²æ„é€ å™¨'}]</small></div>
                    <div id="sd-mode-builder" style="display:${settings.useRawMode ? 'none' : 'block'}">
                        <h4 style="margin-bottom:10px; border-bottom:1px solid #555; padding-bottom:5px;">è§’è‰²ç‰¹å¾æ•°æ®åº“ (Character DB)</h4>
                        <div id="sd-char-list-container"></div>
                        <button id="sd-add-char" class="sd-add-btn">+ æ·»åŠ è§’è‰² (Add Character)</button>
                        <div class="sd-accordion" id="sd-tpl-top-header"><span>å‰ç½®æ¨¡ç‰ˆ (Template Top)</span> <span>â–¿</span></div>
                        <div class="sd-accordion-content" id="sd-tpl-top-content"><textarea id="sd-tpl-top" class="text_pole" rows="6" style="width:100%; font-family:monospace; font-size:0.8em;">${settings.templateTop}</textarea></div>
                        <div class="sd-accordion" id="sd-tpl-bot-header"><span>åç½®æ¨¡ç‰ˆ (Template Bottom)</span> <span>â–¿</span></div>
                        <div class="sd-accordion-content" id="sd-tpl-bot-content"><textarea id="sd-tpl-bot" class="text_pole" rows="6" style="width:100%; font-family:monospace; font-size:0.8em;">${settings.templateBottom}</textarea></div>
                    </div>
                    <div id="sd-mode-raw" style="display:${settings.useRawMode ? 'block' : 'none'}">
                        <label>å®Œæ•´æ³¨å…¥æ–‡æœ¬ (Raw Prompt):</label>
                        <textarea id="sd-inject-prompt-raw" class="text_pole" rows="15" style="width:100%; font-family:monospace">${settings.injectPrompt}</textarea>
                    </div>
                </div>
                <div id="${contentCfgId}" class="sd-tab-content">
                    <label class="checkbox_label" style="margin-bottom: 15px; display: flex; align-items: center;"><input type="checkbox" id="sd-enable-toggle" ${settings.enabled ? 'checked' : ''} /> <span style="margin-left: 8px;">å¯ç”¨ç”Ÿå›¾è§£æåŠŸèƒ½ (Image Parsing)</span></label>
                    <div style="margin-bottom: 10px;"><label>å…¨å±€å‰ç¼€ (Prefix):</label><textarea id="sd-prefix" class="text_pole" rows="2" style="width:100%; font-family:monospace">${settings.globalPrefix}</textarea></div>
                    <div style="margin-bottom: 10px;"><label>å…¨å±€åç¼€ (Suffix):</label><textarea id="sd-suffix" class="text_pole" rows="2" style="width:100%; font-family:monospace">${settings.globalSuffix}</textarea></div>
                    <div style="margin-bottom: 15px;"><label>å…¨å±€è´Ÿé¢ (Negative):</label><textarea id="sd-negative" class="text_pole" rows="3" style="width:100%; font-family:monospace">${settings.globalNegative}</textarea></div>
                    <div style="margin-top:20px; border-top:1px solid #555; padding-top:15px;">
                        <label style="font-weight:bold;">é…ç½®åŒæ­¥ (Configuration Sync):</label>
                        <div style="display:flex; gap:10px; margin-top:10px;">
                            <button id="${btnExpId}" class="menu_button" style="flex:1;">ğŸ“¤ å¯¼å‡ºé…ç½® (Export)</button>
                            <button id="${btnImpId}" class="menu_button" style="flex:1;">ğŸ“¥ å¯¼å…¥é…ç½® (Import)</button>
                        </div>
                    </div>
                </div>
                <div id="${contentApiId}" class="sd-tab-content">
                    <div class="sd-placeholder" style="margin-bottom:15px; text-align:left; padding:10px;">åœ¨æ­¤é…ç½®å…¼å®¹ OpenAI æ ¼å¼çš„ APIä»¥æ”¯æŒ"AIæ›´æ–°"åŠŸèƒ½ã€‚</div>
                    <div style="margin-bottom: 10px;"><label>APIåŸºç¡€URL (Base URL):</label><input type="text" id="sd-api-url" class="text_pole" style="width:100%" value="${settings.llmConfig.baseUrl}" placeholder="http://127.0.0.1:7861/v1" /></div>
                    <div style="margin-bottom: 10px;"><label>APIå¯†é’¥ (API Key):</label><input type="password" id="sd-api-key" class="text_pole" style="width:100%" value="${settings.llmConfig.apiKey}" placeholder="sk-..." /></div>
                    <div style="display:flex; gap:10px; margin-bottom:10px; align-items:flex-end;">
                        <div style="flex:1"><label>é€‰æ‹©æ¨¡å‹:</label><select id="sd-api-model" class="text_pole" style="width:100%"><option value="${settings.llmConfig.model}">${settings.llmConfig.model || 'æœªé€‰æ‹©'}</option></select></div>
                        <button id="sd-api-load-btn" class="menu_button" style="width:100px; height:38px;">è¿æ¥åŠ è½½</button>
                    </div>
                    <div style="display:flex; gap:10px;">
                         <div style="flex:1"><label>æœ€å¤§Tokens (ç”Ÿæˆé•¿åº¦):</label><input type="number" id="sd-api-tokens" class="text_pole" value="${settings.llmConfig.maxTokens}" style="width:100%" placeholder="4096" /></div>
                        <div style="flex:1"><label>æ¸©åº¦ (Temperature):</label><input type="number" id="sd-api-temp" class="text_pole" value="${settings.llmConfig.temperature}" step="0.1" max="2.0" style="width:100%" /></div>
                    </div>
                </div>
                <div id="${contentLogId}" class="sd-tab-content"><textarea readonly class="text_pole" style="width:100%; height:300px; font-family:monospace; font-size:0.8em; white-space:pre;">${logText}</textarea></div>
                <button id="${btnResetId}" class="menu_button" style="width: 100%; padding: 10px; background-color: #666; color: #fff; margin-top: 5px;">
                    <i class="fa-solid fa-rotate-left"></i> é‡ç½®ä¸ºé»˜è®¤è®¾ç½®
                </button>
                <button id="${btnSaveId}" class="menu_button" style="width: 100%; padding: 10px; background-color: var(--SmartThemeQuoteColor); color: #fff; margin-top: 10px;">
                    <i class="fa-solid fa-save"></i> ä¿å­˜è®¾ç½®
                </button>
            </div>`;
            
        SillyTavern.callGenericPopup(popupHtml, 1, '', { wide: false });
        
        setTimeout(() => {
            const switchTab = (activeTab, activeContent) => {
                $(`#${tabCfgId}, #${tabInjId}, #${tabLogId}, #${tabApiId}`).removeClass('active');
                $(`#${contentCfgId}, #${contentInjId}, #${contentLogId}, #${contentApiId}`).removeClass('active');
                activeTab.addClass('active'); activeContent.addClass('active');
            };
            $(`#${tabCfgId}`).on('click', () => switchTab($(`#${tabCfgId}`), $(`#${contentCfgId}`)));
            $(`#${tabInjId}`).on('click', () => switchTab($(`#${tabInjId}`), $(`#${contentInjId}`)));
            $(`#${tabLogId}`).on('click', () => switchTab($(`#${tabLogId}`), $(`#${contentLogId}`)));
            $(`#${tabApiId}`).on('click', () => switchTab($(`#${tabApiId}`), $(`#${contentApiId}`)));

            const $charContainer = $('#sd-char-list-container');
            const renderCharRow = (name, tags, enabled) => {
                const $row = $(`<div class="sd-char-row"><input type="checkbox" class="sd-char-enable" ${enabled?'checked':''} style="margin-top:10px; margin-right:5px; cursor:pointer;" title="æ˜¯å¦å¯ç”¨æ­¤è§’è‰²" /><input type="text" class="text_pole sd-char-name" placeholder="è§’è‰²å" value="${name}" /><textarea class="text_pole sd-char-tags" rows="2" placeholder="å›ºå®šç‰¹å¾ (Fixed Tags)">${tags}</textarea><button class="sd-char-del" title="åˆ é™¤">âœ•</button></div>`);
                $row.find('.sd-char-del').on('click', () => $row.remove());
                $charContainer.append($row);
            };
            if (settings.characters && settings.characters.length > 0) settings.characters.forEach(c => renderCharRow(c.name, c.tags, c.enabled !== false));
            else renderCharRow('', '', true);
            $('#sd-add-char').on('click', () => renderCharRow('', '', true));

            const toggleAccord = (headerId, contentId) => {
                $(`#${headerId}`).on('click', () => {
                    $(`#${contentId}`).toggleClass('show');
                    $(`#${headerId} span:last-child`).text($(`#${contentId}`).hasClass('show') ? 'â–µ' : 'â–¿');
                });
            };
            toggleAccord('sd-tpl-top-header', 'sd-tpl-top-content');
            toggleAccord('sd-tpl-bot-header', 'sd-tpl-bot-content');

            $('#sd-mode-toggle').on('click', () => {
                settings.useRawMode = !settings.useRawMode;
                $('#sd-mode-builder').toggle(!settings.useRawMode);
                $('#sd-mode-raw').toggle(settings.useRawMode);
                $('#sd-mode-toggle').text(`[åˆ‡æ¢æ¨¡å¼: ${settings.useRawMode ? 'åŸå§‹æ–‡æœ¬' : 'è§’è‰²æ„é€ å™¨'}]`);
            });

            $(`#${btnExpId}`).on('click', function() {
                 const html = `<div style="padding:10px;"><h3>å¯¼å‡ºé…ç½® (Export)</h3><textarea class="text_pole" rows="10" style="width:100%; font-family:monospace; font-size:0.8em;">${JSON.stringify(settings, null, 2)}</textarea></div>`;
                 SillyTavern.callGenericPopup(html, 1, '', { wide: false });
            });
            $(`#${btnImpId}`).on('click', function() {
                 const taId = `sd-imp-ta-${Date.now()}`; const confirmId = `sd-imp-confirm-${Date.now()}`;
                 const html = `<div style="padding:10px;"><h3>å¯¼å…¥é…ç½® (Import)</h3><textarea id="${taId}" class="text_pole" rows="10" style="width:100%; font-family:monospace; font-size:0.8em;"></textarea><button id="${confirmId}" class="menu_button" style="width:100%; margin-top:10px; background:var(--SmartThemeQuoteColor); color:#fff;">ç¡®è®¤å¯¼å…¥</button></div>`;
                 SillyTavern.callGenericPopup(html, 1, '', { wide: false });
                 setTimeout(() => {
                     $(`#${confirmId}`).on('click', () => {
                         try { settings = { ...DEFAULT_SETTINGS, ...JSON.parse($(`#${taId}`).val()) }; saveSettings(); toastr.success('é…ç½®å¯¼å…¥æˆåŠŸï¼'); closeCurrentPopup(this); } 
                         catch(e) { toastr.error('è§£æé”™è¯¯: ' + e.message); }
                     });
                 }, 100);
            });

            $('#sd-api-load-btn').on('click', async function() {
                 const btn = $(this); const url = $('#sd-api-url').val().trim(); const key = $('#sd-api-key').val().trim();
                 if(!url) { toastr.warning('è¯·è¾“å…¥åŸºç¡€URL'); return; }
                 btn.prop('disabled', true).text('åŠ è½½ä¸­...');
                 try { 
                     const models = await fetchModels(url, key);
                     const $sel = $('#sd-api-model').empty();
                     if(Array.isArray(models)) models.forEach(m => $sel.append(`<option value="${m.id||m.model_name||m}">${m.id||m.model_name||m}</option>`));
                     toastr.success('æ¨¡å‹åˆ—è¡¨åŠ è½½æˆåŠŸ');
                 } catch(e) { toastr.error('åŠ è½½å¤±è´¥: ' + e.message); }
                 finally { btn.prop('disabled', false).text('è¿æ¥åŠ è½½'); }
            });

            $(`#${btnSaveId}`).on('click', function() {
                settings.enabled = $('#sd-enable-toggle').is(':checked');
                settings.globalPrefix = $('#sd-prefix').val(); settings.globalSuffix = $('#sd-suffix').val(); settings.globalNegative = $('#sd-negative').val();
                settings.injectEnabled = $('#sd-inject-enable').is(':checked'); settings.injectDepth = parseInt($('#sd-inject-depth').val()) || 0; settings.injectRole = $('#sd-inject-role').val(); settings.aiUpdateWithTemplate = $('#sd-ai-tmpl-enable').is(':checked'); 
                settings.llmConfig.baseUrl = $('#sd-api-url').val().trim(); settings.llmConfig.apiKey = $('#sd-api-key').val().trim(); settings.llmConfig.model = $('#sd-api-model').val(); settings.llmConfig.maxTokens = parseInt($('#sd-api-tokens').val()) || 500; settings.llmConfig.temperature = parseFloat($('#sd-api-temp').val()) || 0.7;
                if (settings.useRawMode) settings.injectPrompt = $('#sd-inject-prompt-raw').val();
                else {
                    const chars = []; $('.sd-char-row').each(function() { const n=$(this).find('.sd-char-name').val().trim(),t=$(this).find('.sd-char-tags').val().trim(),e=$(this).find('.sd-char-enable').is(':checked'); if(n)chars.push({name:n,tags:t,enabled:e}); });
                    settings.templateTop = $('#sd-tpl-top').val(); settings.templateBottom = $('#sd-tpl-bot').val(); settings.characters = chars;
                    settings.injectPrompt = `${settings.templateTop}\n${chars.filter(c=>c.enabled).map(c=>`* **${c.name}**: ${c.tags}`).join('\n')}\n${settings.templateBottom}`;
                    $('#sd-inject-prompt-raw').val(settings.injectPrompt);
                }
                saveSettings(); toastr.success('è®¾ç½®å·²ä¿å­˜'); closeCurrentPopup(this); processChatDOM();
            });

            $(`#${btnResetId}`).on('click', function () {
                if (!confirm('ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤è®¾ç½®å—ï¼Ÿè¿™ä¼šè¦†ç›–å½“å‰æ‰€æœ‰é…ç½®ã€‚')) return;

                settings = {
                    ...DEFAULT_SETTINGS,
                    llmConfig: { ...DEFAULT_SETTINGS.llmConfig }
                };

                localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));

                if (typeof toastr !== 'undefined') {
                    toastr.success('å·²é‡ç½®ä¸ºé»˜è®¤è®¾ç½®ï¼Œè¯·å…³é—­å¹¶é‡æ–°æ‰“å¼€è®¾ç½®çª—å£æŸ¥çœ‹ã€‚');
                } else {
                    alert('å·²é‡ç½®ä¸ºé»˜è®¤è®¾ç½®ï¼Œè¯·å…³é—­å¹¶é‡æ–°æ‰“å¼€è®¾ç½®çª—å£æŸ¥çœ‹ã€‚');
                }

                try {
                    $('#genericPopupClose, .popup-button-ok').last().trigger('click');
                } catch (e) {}
            });
        }, 100);
    }

    async function triggerSlash(cmd) {
        const trigger = (window.triggerSlash || window.parent?.triggerSlash || window.parent?.TavernHelper?.triggerSlash);
        if (!trigger) throw new Error('APIä¸å¯ç”¨');
        return await trigger.call(window.parent || window, cmd);
    }

    function handleContextInjection(data) {
        if (!settings.enabled || !settings.injectEnabled) return;
        let contextArray = Array.isArray(data) ? data : (data && Array.isArray(data.chat) ? data.chat : null);
        if (!contextArray && data && typeof data === 'object') {
             for (const key in data) if (Array.isArray(data[key]) && data[key].length > 0 && (data[key][0].role || data[key][0].name)) { contextArray = data[key]; break; }
        }
        if (!contextArray || !settings.injectPrompt) return;
        if (contextArray.some(msg => (msg.content === settings.injectPrompt) || (msg.mes === settings.injectPrompt))) return;
        const depth = Math.max(0, parseInt(settings.injectDepth) || 0);
        let targetIdx = contextArray.length - depth; if (targetIdx < 0) targetIdx = 0;
        contextArray.splice(targetIdx, 0, { role: settings.injectRole || 'system', content: settings.injectPrompt });
        addLog('INJECT', `Inserted prompt at index ${targetIdx}`);
    }

    function registerSTEvents() {
        if (!SillyTavern.eventSource) {
            addLog('ERROR', 'SillyTavern.eventSource ä¸å¯ç”¨');
            return;
        }

        // æ³¨å…¥ä¸Šä¸‹æ–‡
        try { 
            SillyTavern.eventSource.on('chat_completion_prompt_ready', handleContextInjection); 
            addLog('EVENT', 'âœ… å·²æ³¨å†Œäº‹ä»¶: chat_completion_prompt_ready');
        } catch(e) {
            addLog('ERROR', `æ³¨å†Œ chat_completion_prompt_ready å¤±è´¥: ${e.message}`);
        }

        const debouncedProcess = () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                persistentListenCount = 0;
                processChatDOMWithPersistentListening();
            }, 500);
        };

        const eventTypes = SillyTavern.eventTypes || {};
        
        if (eventTypes.USER_MESSAGE_RENDERED || 'user_message_rendered') {
            const eventName = eventTypes.USER_MESSAGE_RENDERED || 'user_message_rendered';
            SillyTavern.eventSource.on(eventName, (messageId) => {
                addLog('EVENT', `âœ… [USER_MESSAGE_RENDERED] è§¦å‘ - æ¶ˆæ¯ID: ${messageId}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        if (eventTypes.CHARACTER_MESSAGE_RENDERED || 'character_message_rendered') {
            const eventName = eventTypes.CHARACTER_MESSAGE_RENDERED || 'character_message_rendered';
            SillyTavern.eventSource.on(eventName, (messageId) => {
                addLog('EVENT', `âœ… [CHARACTER_MESSAGE_RENDERED] è§¦å‘ - æ¶ˆæ¯ID: ${messageId}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        if (eventTypes.CHAT_CHANGED || 'chat_changed') {
            const eventName = eventTypes.CHAT_CHANGED || 'chat_changed';
            SillyTavern.eventSource.on(eventName, (chatFilename) => {
                addLog('EVENT', `âœ… [CHAT_CHANGED] è§¦å‘ - èŠå¤©æ–‡ä»¶: ${chatFilename}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        if (eventTypes.MESSAGE_UPDATED || 'message_updated') {
            const eventName = eventTypes.MESSAGE_UPDATED || 'message_updated';
            SillyTavern.eventSource.on(eventName, (messageId) => {
                addLog('EVENT', `âœ… [MESSAGE_UPDATED] è§¦å‘ - æ¶ˆæ¯ID: ${messageId}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        if (eventTypes.MESSAGE_SWIPED || 'message_swiped') {
            const eventName = eventTypes.MESSAGE_SWIPED || 'message_swiped';
            SillyTavern.eventSource.on(eventName, (messageId) => {
                addLog('EVENT', `âœ… [MESSAGE_SWIPED] è§¦å‘ - æ¶ˆæ¯ID: ${messageId}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        if (eventTypes.GENERATION_ENDED || 'generation_ended') {
            const eventName = eventTypes.GENERATION_ENDED || 'generation_ended';
            SillyTavern.eventSource.on(eventName, (messageId) => {
                addLog('EVENT', `âœ… [GENERATION_ENDED] è§¦å‘ - æ¶ˆæ¯ID: ${messageId}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        if (eventTypes.MESSAGE_RECEIVED || 'message_received') {
            const eventName = eventTypes.MESSAGE_RECEIVED || 'message_received';
            SillyTavern.eventSource.on(eventName, (messageId) => {
                addLog('EVENT', `âœ… [MESSAGE_RECEIVED] è§¦å‘ - æ¶ˆæ¯ID: ${messageId}`);
                debouncedProcess();
            });
            addLog('EVENT', `âœ… å·²æ³¨å†Œäº‹ä»¶: ${eventName}`);
        }

        addLog('EVENT', 'âœ… æ‰€æœ‰é…’é¦†äº‹ä»¶ç›‘å¬å·²æ³¨å†Œå®Œæˆ');
    }
})();
